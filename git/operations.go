package git

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
	"time"
)

// Manager handles git operations for safety and rollback
type Manager struct {
	projectPath string
	enabled     bool
}

// NewManager creates a new git manager
func NewManager(projectPath string) *Manager {
	// Check if git is available and this is a git repo
	enabled := isGitRepo(projectPath)

	return &Manager{
		projectPath: projectPath,
		enabled:     enabled,
	}
}

// IsEnabled returns whether git integration is enabled
func (m *Manager) IsEnabled() bool {
	return m.enabled
}

// isGitRepo checks if the directory is a git repository
func isGitRepo(path string) bool {
	cmd := exec.Command("git", "rev-parse", "--git-dir")
	cmd.Dir = path
	return cmd.Run() == nil
}

// CheckStatus returns the current git status
func (m *Manager) CheckStatus() (string, error) {
	if !m.enabled {
		return "", nil
	}

	cmd := exec.Command("git", "status", "--short")
	cmd.Dir = m.projectPath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get git status: %w", err)
	}

	return string(output), nil
}

// HasUncommittedChanges checks if there are uncommitted changes
func (m *Manager) HasUncommittedChanges() (bool, error) {
	if !m.enabled {
		return false, nil
	}

	status, err := m.CheckStatus()
	if err != nil {
		return false, err
	}

	return strings.TrimSpace(status) != "", nil
}

// CreateCommit creates a commit with the given files and message
func (m *Manager) CreateCommit(files []string, message string) error {
	if !m.enabled {
		return nil
	}

	// Add files
	for _, file := range files {
		cmd := exec.Command("git", "add", file)
		cmd.Dir = m.projectPath

		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to add file %s: %w", file, err)
		}
	}

	// Commit
	cmd := exec.Command("git", "commit", "-m", message)
	cmd.Dir = m.projectPath

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to commit: %s", stderr.String())
	}

	return nil
}

// CreateSafetyCommit creates a commit with auto-generated message
func (m *Manager) CreateSafetyCommit(testFile string, coverageGain float64) error {
	if !m.enabled {
		return nil
	}

	message := fmt.Sprintf(
		"test: Add/update tests for %s (%.2f%% coverage gain)\n\nGenerated by test-coverage-agent at %s",
		testFile,
		coverageGain,
		time.Now().Format(time.RFC3339),
	)

	return m.CreateCommit([]string{testFile}, message)
}

// CreateBranchForSession creates a new branch for this test generation session
func (m *Manager) CreateBranchForSession(branchName string) error {
	if !m.enabled {
		return nil
	}

	cmd := exec.Command("git", "checkout", "-b", branchName)
	cmd.Dir = m.projectPath

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		// Branch might already exist, try to checkout
		cmd = exec.Command("git", "checkout", branchName)
		cmd.Dir = m.projectPath
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to create/checkout branch: %s", stderr.String())
		}
	}

	return nil
}

// GetCurrentBranch returns the name of the current branch
func (m *Manager) GetCurrentBranch() (string, error) {
	if !m.enabled {
		return "", nil
	}

	cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	cmd.Dir = m.projectPath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get current branch: %w", err)
	}

	return strings.TrimSpace(string(output)), nil
}

// CreateStash creates a git stash of current changes
func (m *Manager) CreateStash(message string) error {
	if !m.enabled {
		return nil
	}

	cmd := exec.Command("git", "stash", "push", "-m", message)
	cmd.Dir = m.projectPath

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to create stash: %w", err)
	}

	return nil
}

// GetLastCommitHash returns the hash of the last commit
func (m *Manager) GetLastCommitHash() (string, error) {
	if !m.enabled {
		return "", nil
	}

	cmd := exec.Command("git", "rev-parse", "HEAD")
	cmd.Dir = m.projectPath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get last commit hash: %w", err)
	}

	return strings.TrimSpace(string(output)), nil
}

// ResetToCommit resets to a specific commit (for rollback)
func (m *Manager) ResetToCommit(commitHash string) error {
	if !m.enabled {
		return nil
	}

	cmd := exec.Command("git", "reset", "--hard", commitHash)
	cmd.Dir = m.projectPath

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to reset to commit %s: %w", commitHash, err)
	}

	return nil
}

// ShowDiff shows the diff of uncommitted changes
func (m *Manager) ShowDiff() (string, error) {
	if !m.enabled {
		return "", nil
	}

	cmd := exec.Command("git", "diff")
	cmd.Dir = m.projectPath

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get diff: %w", err)
	}

	return string(output), nil
}

// GetCommitsSince returns commits since a specific commit
func (m *Manager) GetCommitsSince(commitHash string) ([]string, error) {
	if !m.enabled {
		return nil, nil
	}

	cmd := exec.Command("git", "log", "--oneline", commitHash+"..HEAD")
	cmd.Dir = m.projectPath

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get commits: %w", err)
	}

	lines := strings.Split(strings.TrimSpace(string(output)), "\n")
	if len(lines) == 1 && lines[0] == "" {
		return []string{}, nil
	}

	return lines, nil
}
